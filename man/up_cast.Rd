% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/cast.R
\name{up_cast}
\alias{up_cast}
\title{Force method dispatch to use a superclass}
\usage{
up_cast(object, class = NULL)
}
\arguments{
\item{object}{An R7 object}

\item{class}{An R7 class specification, passed to \code{\link[=as_class]{as_class()}}. Must be a
superclass of \code{object}. If not specified, defaults to the parent of
\code{object}.}
}
\value{
An \code{R7_up_class} object which should always be passed
immediately to a generic. It has no other special behavior.
}
\description{
When implementing a method, it's often useful to borrow some of the
implementation from the method for a superclass. \code{up_cast()} lets you
re-call a generic, forcing method dispatch to use the method for a parent,
without modifying (and hence making a copy) of the object that you're
working with.
}
\section{Compared to S3 and S4}{
\code{up_cast()} performs a similar role to \code{\link[=NextMethod]{NextMethod()}} in S3 or
\code{\link[methods:NextMethod]{methods::callNextMethod()}} in S4. It has two main differences:
\itemize{
\item When you call \code{up_cast()} you must specify which parent method you
want to call.
\item You must manually pass along all of the arguments.
}

This makes \code{up_cast()} more verbose, but substantially easier to reason
about. It also avoids some of the dynamism of \code{nextMethod()}: registering
methods for a parent class can not method dispatch for a child class.
}

\examples{
foo1 <- new_class("foo1", properties = list(x = "numeric", y = "numeric"))
foo2 <- new_class("foo2", foo1, properties = list(z = "numeric"))

total <- new_generic("total", "x")
method(total, foo1) <- function(x) x@x + x@y

# This doesn't work because it'll be stuck in an infinite loop:
method(total, foo2) <- function(x) total(x) + x@z

# This ensures the nested total calls the parent method
method(total, foo2) <- function(x) total(up_cast(x)) + x@z

total(foo2(1, 2, 3))
}
