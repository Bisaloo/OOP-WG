make_wrappers <- function() {
  formals <- lapply(mget(to_wrap(), baseenv()), formals2)
  funs <- Map(make_wrapper, names(formals), formals)
  defs <- vcapply(funs, function(x) paste0(deparse(x), "\n", collapse = ""))

  lines <- c(
    "# Automatically generated by make_wrappers()",
    "# Do not edit by hand",
    "",
    paste0(
      "#' @export\n",
      "`", names(funs), ".S7_object` <- ", defs
    )
  )
  writeLines(lines, "R/wrappers-generated.R")
}

to_wrap <- function() {
  is_s3_generic <- function(f)  {
    if (!is.function(f)) return(FALSE)

    uses <- getExportedValue("codetools", "findGlobals")(f, merge = FALSE)$functions
    any(uses == "UseMethod")
  }

  primitive <- .S3PrimitiveGenerics

  funs <- mget(ls("package:base"), as.environment("package:base"))
  s3generics <- names(Filter(is_s3_generic, funs))

  # Extracted from ?"internal generic"
  internal <- c("[", "[[", "$", "[<-", "[[<-", "$<-", "unlist", "cbind", "rbind", "as.vector")

  all <- unique(c(s3generics, primitive, internal))
  # already implemented
  all <- setdiff(all, c(
    # Already implemented
    "[", "[[", "$", "[<-", "[[<-", "$<-", "print",
    # Can't error because it breaks RStudio environment/rlang
    "length", "dim",
    # only in 4.2.1
    "mtfrm",
    # roxygen2 method auto-registration fails
    "unlist"
  ))

  sort(all)
}

make_wrapper <- function(name, args) {
  body <- substitute(
    {
      if (is.pairlist(first_arg)) {
        method_not_implemented(generic, first_arg)
      } else {
        NextMethod()
      }
    },
    list(
      generic = name,
      first_arg = as.symbol(names(args)[[1]])
    )
  )
  new_function(args, body, globalenv())
}

formals2 <- function(x) {
  formals(args(x))
}

method_not_implemented <- function(generic, x) {
  stop(
    sprintf(
      "%s() is not implemented for S7 object %s.",
      generic,
      obj_desc(x)
    ),
    call. = FALSE
  )
}

# Hand-written wrappers ---------------------------------------------------

#' @export
dim.S7_object <- function(x, ...) {
  if (is.pairlist(x)) {
    NULL
  } else {
    NextMethod()
  }
}
#' @export
length.S7_object <- function(x, ...) {
  if (is.pairlist(x)) {
    0
  } else {
    NextMethod()
  }
}

#' @export
Math.S7_object <- function(x, ...) {
  if (is.pairlist(x)) {
    method_not_implemented(.Generic, x)
  } else {
    NextMethod()
  }
}
#' @export
Summary.S7_object <- function(..., na.rm = FALSE) {
  if (is.pairlist(..1)) {
    method_not_implemented(.Generic, ..1)
  } else {
    NextMethod()
  }
}
#' @export
Complex.S7_object <- function(z) {
  if (is.pairlist(z)) {
    method_not_implemented(.Generic, z)
  } else {
    NextMethod()
  }
}

#' @method unlist S7_object
#' @export
unlist.S7_object <- function(x, recursive = TRUE, use.names = TRUE) {
  if (is.pairlist(x)) {
    method_not_implemented("unlist", x)
  } else {
    NextMethod()
  }
}
